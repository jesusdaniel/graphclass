i = i+1
}
res <- data.frame(rho_cors, t(matrix(unlist(list_res), nrow = 3)))
names(res) <- c("rho", "T", "Spectral", "SpectralHat")
return(res)
}
library(iGraphMatch)
library(lattice)
library(igraph)
library(Matrix)
#install.packages("MCMCpack")
library(MCMCpack)
#remove.packages("ggplot2")
#install.packages("ggplot2")
library(ggplot2)
#install.packages("plotly")
#library(plotly)
library(plot3D)
library(reshape2)
library(ggplot2)
#N = 500
n_c = 50
rho = 1
alpha = 1
diric_conc <- 0.1
sim_instance_RDPG_hetjunk <- function(n_c, rho, alpha, diric_conc) {
N = 250
require(iGraphMatch)
require(lattice)
require(igraph)
require(Matrix)
#install.packages("MCMCpack")
require(MCMCpack)
X_core <- rdirichlet(n = n_c, c(1,1,1) * diric_conc)*alpha
X1j <- rdirichlet(n = N - n_c, c(1,1,1) * diric_conc)*alpha
X2j <- rdirichlet(n = N - n_c, c(1,1,1) * diric_conc)*alpha
X1 <- rbind(X_core, X1j)
X2 <- rbind(X_core, X2j)
G1 <- igraph::sample_dot_product(directed = FALSE, vecs = t(X1))
G2 <- igraph::sample_dot_product(directed = FALSE, vecs = t(X2))
A = get.adjacency(G1)
B = get.adjacency(G2)
pair_core =  iGraphMatch::sample_correlated_rdpg(X_core, rho)
A1 = get.adjacency(pair_core$graph1)
B1 = get.adjacency(pair_core$graph2)
#levelplot(as.matrix(A))
#levelplot(as.matrix(A-B))
A[1:n_c, 1:n_c] <- A1
B[1:n_c, 1:n_c] <- B1
W1 = tcrossprod(X1)
W2 = tcrossprod(X2)
match = graph_match_FW(A, B, seeds = 1:n_c)
#plot to see if core elememnts where correctly matched
#plot(diag(match$P))
# Matched adjacency matrix B
BP = B[match$corr, match$corr]
M =(A-W1) * (BP-W2)
#Mc = M/sqrt(W1*(1-W1) * W2 * (1-W2))
#diag(Mc) = 0
#levelplot(as.matrix(Mc))
# Estimated EA and EB
eA = eigen(A);   eB = eigen(BP)
#Number of eigenvalues
L =  2
Ahat = eA$vectors[,1:L] %*%
diag(eA$values[1:L], nrow = length(eA$values[1:L])) %*% t(eA$vectors[,1:L])
Bhat = eB$vectors[,1:L] %*% diag(eB$values[1:2], nrow = L) %*% t(eB$vectors[,1:L])
#Number of eigenvalues
L =  3
Ahat = eA$vectors[,1:L] %*%
diag(eA$values[1:L], nrow = length(eA$values[1:L])) %*% t(eA$vectors[,1:L])
Bhat = eB$vectors[,1:L] %*% diag(eB$values[1:2], nrow = L) %*% t(eB$vectors[,1:L])
# Correlation matrix, estimated means
Mh =(A-Ahat)*(BP-Bhat)
############### finding core vs junk
# Eigenvectors of correlation
Vh = eigen(Mh)$vectors
# Eigenvectors of true correlation
V =eigen(M)$vectors
# errors
delta_v <- colSums(abs(A-BP))
n <- nrow(A)
dAv <- rowSums(A)
dBv <- rowSums(B)
E_delta_v <- mean(dBv) + dAv*(1-2*(mean(dBv)/(n - 1)))
Var_delta_v = (1 - 2*dAv/(n - 1))^2*var(dBv) + 4*dAv * (n - 1 - dAv) *
((n-1)*mean(dBv) - mean(dBv^2)) / ((n-1)^2*(n-2))
Tv = (delta_v - E_delta_v) / Var_delta_v
#plot(Vh[,1], main = "Spectral-hat leading eigenvector (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:50, junk=51:250")
#plot(V[,1], main = "Spectral leading eigenvector (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:200, junk=201:250")
#plot(Tv, main = "T statistic (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:50, junk=51:250")
#plot(delta_v)
#install.packages("mclust")
corejunk_true <- c(rep(1, n_c), rep(2, n-n_c))
clust_errors <- function(vertex_val, corejunk_true) {
#core_junk <- kmeans(vertex_val, 2)
require(mclust)
core_junk <- Mclust(data = vertex_val, G = 2)
#conf_mat <- table(corejunk_true, core_junk$cluster)
conf_mat <- table(corejunk_true, core_junk$classification)
error = sum(conf_mat) - max(sum(diag(conf_mat)), sum(conf_mat) - sum(diag(conf_mat)))
#plot(vertex_val, col = core_junk$classification)
return(error)
}
c(clust_errors(Tv, corejunk_true),
clust_errors(V[,1], corejunk_true),
clust_errors(Vh[,1], corejunk_true))
}
# For each model (same latent positions, different latent positionss) and core size,
# run 3 cases: low degree (d/10), high degree (d/2), and
library(parallel)
cl <- makeCluster(10)
rho_cors <- seq(0, 1, length.out = 11)
simulate_grid <- function(seed, rho_cors, n_c, alpha, diric_conc) {
set.seed(seed)
list_res <- list()
i=1
for(rho in rho_cors) {
list_res[[i]] <- sim_instance_RDPG_hetjunk(n_c, rho, alpha, diric_conc)
print(i)
i = i+1
}
res <- data.frame(rho_cors, t(matrix(unlist(list_res), nrow = 3)))
names(res) <- c("rho", "T", "Spectral", "SpectralHat")
return(res)
}
clusterEvalQ(cl = cl, library(iGraphMatch))
clusterEvalQ(cl = cl, library(igraph))
clusterEvalQ(cl = cl, library(Matrix))
clusterExport(cl = cl, varlist = list("simulate_grid",
"sim_instance_RDPG_hetjunk", "rho_cors"))
N = 250
# homogeneous, alpha = 1, dirichlet concentration = 1
alpha = 1
diric_conc = 1
grid_results50 <- parLapply(cl = cl, 1:8, simulate_grid, rho_cors = rho_cors, n_c = 50, alpha = alpha, diric_conc = diric_conc)
grid_results125 <- parLapply(cl = cl, 1:8, simulate_grid, rho_cors = rho_cors, n_c = 125, alpha = alpha, diric_conc = diric_conc)
grid_results200 <- parLapply(cl = cl, 1:8, simulate_grid, rho_cors = rho_cors, n_c = 200, alpha = alpha, diric_conc = diric_conc)
mean_performance1 <- Reduce('+', grid_results50)/8
mean_performance2 <- Reduce('+', grid_results125)/8
mean_performance3 <- Reduce('+', grid_results200)/8
corejunk_res_a1_dc1 <- rbind(cbind(n_c = 50, mean_performance1, parameters = "alp=1,dc=1"),
cbind(n_c = 125, mean_performance2, parameters = "alp=1,dc=1"),
cbind(n_c = 200, mean_performance3, parameters = "alp=1,dc=1"))
corejunk_table_a1_dc1 <- melt(corejunk_res_a1_dc1, id.vars = c("rho", "n_c", "parameters"))
names(corejunk_table_a1_dc1) = c("rho", "n_c", "parameters", "Method", "Number.Misclustered")
ggplot(corejunk_table_a1_dc1, aes(x = rho, y = Number.Misclustered)) +
geom_point(aes(color = Method, shape = Method)) +
geom_line(aes(color = Method, linetype = Method)) +
theme_bw() + facet_grid(. ~ n_c) + ggtitle("Core detection performance for different core sizes (n = 250)")
### homogeneous, alpha = 0.4, dirichlet concentration = 1
alpha = 0.4
diric_conc = 1
grid_results50 <- parLapply(cl = cl, 1:8, simulate_grid, rho_cors = rho_cors, n_c = 50, alpha = alpha, diric_conc = diric_conc)
grid_results125 <- parLapply(cl = cl, 1:8, simulate_grid, rho_cors = rho_cors, n_c = 125, alpha = alpha, diric_conc = diric_conc)
grid_results200 <- parLapply(cl = cl, 1:8, simulate_grid, rho_cors = rho_cors, n_c = 200, alpha = alpha, diric_conc = diric_conc)
mean_performance1 <- Reduce('+', grid_results50)/8
mean_performance2 <- Reduce('+', grid_results125)/8
mean_performance3 <- Reduce('+', grid_results200)/8
corejunk_res_a04_dc1 <- rbind(cbind(n_c = 50, mean_performance1, parameters = "alp=0.4,dc=1"),
cbind(n_c = 125, mean_performance2, parameters = "alp=0.4,dc=1"),
cbind(n_c = 200, mean_performance3, parameters = "alp=0.4,dc=1"))
corejunk_table_a04_dc1 <- melt(corejunk_res_a04_dc1, id.vars = c("rho", "n_c", "parameters"))
names(corejunk_table_a04_dc1) = c("rho", "n_c", "parameters", "Method", "Number.Misclustered")
ggplot(corejunk_table_a04_dc1, aes(x = rho, y = Number.Misclustered)) +
geom_point(aes(color = Method, shape = Method)) +
geom_line(aes(color = Method, linetype = Method)) +
theme_bw() + facet_grid(. ~ n_c) + ggtitle("Core detection performance for different core sizes (n = 250)")
# homogeneous, alpha = 1, dirichlet concentration = 0.1
alpha = 1
diric_conc = 0.1
N = 250
grid_results50 <- parLapply(cl = cl, 1:8, simulate_grid, rho_cors = rho_cors, n_c = 50, alpha = alpha, diric_conc = diric_conc)
grid_results125 <- parLapply(cl = cl, 1:8, simulate_grid, rho_cors = rho_cors, n_c = 125, alpha = alpha, diric_conc = diric_conc)
grid_results200 <- parLapply(cl = cl, 1:8, simulate_grid, rho_cors = rho_cors, n_c = 200, alpha = alpha, diric_conc = diric_conc)
mean_performance1 <- Reduce('+', grid_results50)/8
mean_performance2 <- Reduce('+', grid_results125)/8
mean_performance3 <- Reduce('+', grid_results200)/8
corejunk_res_a1_dc01 <- rbind(cbind(n_c = 50, mean_performance1,  parameters = "alp=1,dc=0.1"),
cbind(n_c = 125, mean_performance2,  parameters = "alp=1,dc=0.1"),
cbind(n_c = 200, mean_performance3,  parameters = "alp=1,dc=0.1"))
corejunk_table_a1_dc01 <- melt(corejunk_res_a1_dc01, id.vars = c("rho", "n_c", "parameters"))
names(corejunk_table_a1_dc01) = c("rho", "n_c", "parameters", "Method", "Number.Misclustered")
ggplot(corejunk_table_a1_dc01, aes(x = rho, y = Number.Misclustered)) +
geom_point(aes(color = Method, shape = Method)) +
geom_line(aes(color = Method, linetype = Method)) +
theme_bw() + facet_grid(. ~ n_c) + ggtitle("Core detection performance for different core sizes (n = 250)")
corejunk_homogeneous_sims <- rbind(corejunk_table_a1_dc1,
corejunk_table_a04_dc1, corejunk_table_a1_dc01)
ggplot(corejunk_homogeneous_sims, aes(x = rho, y = Number.Misclustered)) +
geom_point(aes(color = Method, shape = Method)) +
geom_line(aes(color = Method, linetype = Method)) +
theme_bw() + facet_grid(parameters ~ n_c) + ggtitle("Core detection performance for different core sizes (n = 250)")
N = 250
require(iGraphMatch)
require(lattice)
#N = 500
n_c = 50
#N = 500
n_c = 200
rho = 1
alpha = 1
diric_conc <- 0.1
sim_instance_RDPG_hetjunk <- function(n_c, rho, alpha, diric_conc) {
N = 250
require(iGraphMatch)
require(lattice)
require(igraph)
require(Matrix)
#install.packages("MCMCpack")
require(MCMCpack)
X_core <- rdirichlet(n = n_c, c(1,1,1) * diric_conc)*alpha
X1j <- rdirichlet(n = N - n_c, c(1,1,1) * diric_conc)*alpha
X2j <- rdirichlet(n = N - n_c, c(1,1,1) * diric_conc)*alpha
X1 <- rbind(X_core, X1j)
X2 <- rbind(X_core, X2j)
G1 <- igraph::sample_dot_product(directed = FALSE, vecs = t(X1))
G2 <- igraph::sample_dot_product(directed = FALSE, vecs = t(X2))
A = get.adjacency(G1)
B = get.adjacency(G2)
pair_core =  iGraphMatch::sample_correlated_rdpg(X_core, rho)
A1 = get.adjacency(pair_core$graph1)
B1 = get.adjacency(pair_core$graph2)
#levelplot(as.matrix(A))
#levelplot(as.matrix(A-B))
A[1:n_c, 1:n_c] <- A1
B[1:n_c, 1:n_c] <- B1
W1 = tcrossprod(X1)
W2 = tcrossprod(X2)
match = graph_match_FW(A, B, seeds = 1:n_c)
#plot to see if core elememnts where correctly matched
#plot(diag(match$P))
# Matched adjacency matrix B
BP = B[match$corr, match$corr]
M =(A-W1) * (BP-W2)
#Mc = M/sqrt(W1*(1-W1) * W2 * (1-W2))
#diag(Mc) = 0
#levelplot(as.matrix(Mc))
# Estimated EA and EB
eA = eigen(A);   eB = eigen(BP)
#Number of eigenvalues
L =  2
Ahat = eA$vectors[,1:L] %*%
diag(eA$values[1:L], nrow = length(eA$values[1:L])) %*% t(eA$vectors[,1:L])
Bhat = eB$vectors[,1:L] %*% diag(eB$values[1:2], nrow = L) %*% t(eB$vectors[,1:L])
#Number of eigenvalues
L =  3
Ahat = eA$vectors[,1:L] %*%
diag(eA$values[1:L], nrow = length(eA$values[1:L])) %*% t(eA$vectors[,1:L])
Bhat = eB$vectors[,1:L] %*% diag(eB$values[1:2], nrow = L) %*% t(eB$vectors[,1:L])
# Correlation matrix, estimated means
Mh =(A-Ahat)*(BP-Bhat)
############### finding core vs junk
# Eigenvectors of correlation
Vh = eigen(Mh)$vectors
# Eigenvectors of true correlation
V =eigen(M)$vectors
# errors
delta_v <- colSums(abs(A-BP))
n <- nrow(A)
dAv <- rowSums(A)
dBv <- rowSums(B)
E_delta_v <- mean(dBv) + dAv*(1-2*(mean(dBv)/(n - 1)))
Var_delta_v = (1 - 2*dAv/(n - 1))^2*var(dBv) + 4*dAv * (n - 1 - dAv) *
((n-1)*mean(dBv) - mean(dBv^2)) / ((n-1)^2*(n-2))
Tv = (delta_v - E_delta_v) / Var_delta_v
#plot(Vh[,1], main = "Spectral-hat leading eigenvector (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:50, junk=51:250")
#plot(V[,1], main = "Spectral leading eigenvector (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:200, junk=201:250")
#plot(Tv, main = "T statistic (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:50, junk=51:250")
#plot(delta_v)
#install.packages("mclust")
corejunk_true <- c(rep(1, n_c), rep(2, n-n_c))
clust_errors <- function(vertex_val, corejunk_true) {
#core_junk <- kmeans(vertex_val, 2)
require(mclust)
core_junk <- Mclust(data = vertex_val, G = 2)
#conf_mat <- table(corejunk_true, core_junk$cluster)
conf_mat <- table(corejunk_true, core_junk$classification)
error = sum(conf_mat) - max(sum(diag(conf_mat)), sum(conf_mat) - sum(diag(conf_mat)))
#plot(vertex_val, col = core_junk$classification)
return(error)
}
c(clust_errors(Tv, corejunk_true),
clust_errors(V[,1], corejunk_true),
clust_errors(Vh[,1], corejunk_true))
}
N = 250
require(iGraphMatch)
require(lattice)
require(igraph)
require(Matrix)
#install.packages("MCMCpack")
require(MCMCpack)
X_core <- rdirichlet(n = n_c, c(1,1,1) * diric_conc)*alpha
X1j <- rdirichlet(n = N - n_c, c(1,1,1) * diric_conc)*alpha
X2j <- rdirichlet(n = N - n_c, c(1,1,1) * diric_conc)*alpha
X1 <- rbind(X_core, X1j)
X2 <- rbind(X_core, X2j)
G1 <- igraph::sample_dot_product(directed = FALSE, vecs = t(X1))
G2 <- igraph::sample_dot_product(directed = FALSE, vecs = t(X2))
A = get.adjacency(G1)
B = get.adjacency(G2)
pair_core =  iGraphMatch::sample_correlated_rdpg(X_core, rho)
A1 = get.adjacency(pair_core$graph1)
B1 = get.adjacency(pair_core$graph2)
plot(X1)
plot(X2)
X1
X1j - X2j
X1
X1-X2
G1 <- igraph::sample_dot_product(directed = FALSE, vecs = t(X1))
G2 <- igraph::sample_dot_product(directed = FALSE, vecs = t(X2))
A = get.adjacency(G1)
B = get.adjacency(G2)
pair_core =  iGraphMatch::sample_correlated_rdpg(X_core, rho)
A1 = get.adjacency(pair_core$graph1)
B1 = get.adjacency(pair_core$graph2)
levelplot(as.matrix(A))
levelplot(as.matrix(A-B))
A[1:n_c, 1:n_c] <- A1
B[1:n_c, 1:n_c] <- B1
levelplot(as.matrix(A))
levelplot(as.matrix(A-B))
W1 = tcrossprod(X1)
W2 = tcrossprod(X2)
match = graph_match_FW(A, B, seeds = 1:n_c)
# Matched adjacency matrix B
BP = B[match$corr, match$corr]
M =(A-W1) * (BP-W2)
#Mc = M/sqrt(W1*(1-W1) * W2 * (1-W2))
#diag(Mc) = 0
#levelplot(as.matrix(Mc))
# Estimated EA and EB
eA = eigen(A);   eB = eigen(BP)
#Number of eigenvalues
L =  2
#Number of eigenvalues
L =  3
Ahat = eA$vectors[,1:L] %*%
diag(eA$values[1:L], nrow = length(eA$values[1:L])) %*% t(eA$vectors[,1:L])
Bhat = eB$vectors[,1:L] %*% diag(eB$values[1:2], nrow = L) %*% t(eB$vectors[,1:L])
#Number of eigenvalues
L =  3
Ahat = eA$vectors[,1:L] %*%
diag(eA$values[1:L], nrow = length(eA$values[1:L])) %*% t(eA$vectors[,1:L])
Bhat = eB$vectors[,1:L] %*% diag(eB$values[1:2], nrow = L) %*% t(eB$vectors[,1:L])
# Correlation matrix, estimated means
Mh =(A-Ahat)*(BP-Bhat)
levelplot(as.matrix(Mh))
############### finding core vs junk
# Eigenvectors of correlation
Vh = eigen(Mh)$vectors
# Eigenvectors of true correlation
V =eigen(M)$vectors
# errors
delta_v <- colSums(abs(A-BP))
n <- nrow(A)
dAv <- rowSums(A)
dBv <- rowSums(B)
E_delta_v <- mean(dBv) + dAv*(1-2*(mean(dBv)/(n - 1)))
Var_delta_v = (1 - 2*dAv/(n - 1))^2*var(dBv) + 4*dAv * (n - 1 - dAv) *
((n-1)*mean(dBv) - mean(dBv^2)) / ((n-1)^2*(n-2))
Tv = (delta_v - E_delta_v) / Var_delta_v
plot(Vh[,1], main = "Spectral-hat leading eigenvector (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:50, junk=51:250")
#plot(V[,1], main = "Spectral leading eigenvector (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:200, junk=201:250")
#plot(Tv, main = "T statistic (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:50, junk=51:250")
#plot(delta_v)
#install.packages("mclust")
corejunk_true <- c(rep(1, n_c), rep(2, n-n_c))
plot(Vh[,1], main = "Leading eigenvector of spectral method (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:50, junk=51:250", ylab = "V", col = corejunk_true)
plot(Vh[,1], main = "Leading eigenvector of spectral method (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:250, junk=201:250", ylab = "V", col = corejunk_true)
plot(Tv, main = "T statistic (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:50, junk=51:250")
#plot(V[,1], main = "Spectral leading eigenvector (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:200, junk=201:250")
plot(Tv, main = "Local method statistic (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:250, junk=201:250", ylab = "V", col = corejunk_true)
plot(Vh[,1], main = "Leading eigenvector of spectral method (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:200, junk=201:250", ylab = "V", col = corejunk_true)
#plot(V[,1], main = "Spectral leading eigenvector (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:200, junk=201:250")
plot(Tv, main = "Local method statistic (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:200, junk=201:250", ylab = "V", col = corejunk_true)
#N = 500
n_c = 50
rho = 1
alpha = 1
diric_conc <- 0.1
N = 250
require(iGraphMatch)
require(lattice)
require(igraph)
require(Matrix)
#install.packages("MCMCpack")
require(MCMCpack)
X_core <- rdirichlet(n = n_c, c(1,1,1) * diric_conc)*alpha
X1j <- rdirichlet(n = N - n_c, c(1,1,1) * diric_conc)*alpha
X2j <- rdirichlet(n = N - n_c, c(1,1,1) * diric_conc)*alpha
X1 <- rbind(X_core, X1j)
X2 <- rbind(X_core, X2j)
G1 <- igraph::sample_dot_product(directed = FALSE, vecs = t(X1))
G2 <- igraph::sample_dot_product(directed = FALSE, vecs = t(X2))
A = get.adjacency(G1)
B = get.adjacency(G2)
pair_core =  iGraphMatch::sample_correlated_rdpg(X_core, rho)
A1 = get.adjacency(pair_core$graph1)
B1 = get.adjacency(pair_core$graph2)
A[1:n_c, 1:n_c] <- A1
B[1:n_c, 1:n_c] <- B1
levelplot(as.matrix(A))
levelplot(as.matrix(A-B))
W1 = tcrossprod(X1)
W2 = tcrossprod(X2)
match = graph_match_FW(A, B, seeds = 1:n_c)
# Matched adjacency matrix B
BP = B[match$corr, match$corr]
M =(A-W1) * (BP-W2)
#Mc = M/sqrt(W1*(1-W1) * W2 * (1-W2))
#diag(Mc) = 0
#levelplot(as.matrix(Mh))
# Estimated EA and EB
eA = eigen(A);   eB = eigen(BP)
#Number of eigenvalues
L =  3
Ahat = eA$vectors[,1:L] %*%
diag(eA$values[1:L], nrow = length(eA$values[1:L])) %*% t(eA$vectors[,1:L])
Bhat = eB$vectors[,1:L] %*% diag(eB$values[1:2], nrow = L) %*% t(eB$vectors[,1:L])
# Correlation matrix, estimated means
Mh =(A-Ahat)*(BP-Bhat)
############### finding core vs junk
# Eigenvectors of correlation
Vh = eigen(Mh)$vectors
# Eigenvectors of true correlation
V =eigen(M)$vectors
# errors
delta_v <- colSums(abs(A-BP))
n <- nrow(A)
dAv <- rowSums(A)
dBv <- rowSums(B)
E_delta_v <- mean(dBv) + dAv*(1-2*(mean(dBv)/(n - 1)))
Var_delta_v = (1 - 2*dAv/(n - 1))^2*var(dBv) + 4*dAv * (n - 1 - dAv) *
((n-1)*mean(dBv) - mean(dBv^2)) / ((n-1)^2*(n-2))
Tv = (delta_v - E_delta_v) / Var_delta_v
plot(Vh[,1], main = "Leading eigenvector of spectral method (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:200, junk=201:250", ylab = "V", col = corejunk_true)
#plot(V[,1], main = "Spectral leading eigenvector (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:200, junk=201:250")
plot(Tv, main = "Local method statistic (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:200, junk=201:250", ylab = "V", col = corejunk_true)
plot(Vh[,1], main = "Leading eigenvector of spectral method (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:200, junk=201:250", ylab = "V", col = corejunk_true)
#plot(delta_v)
#install.packages("mclust")
corejunk_true <- c(rep(1, n_c), rep(2, n-n_c))
plot(Vh[,1], main = "Leading eigenvector of spectral method (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:200, junk=201:250", ylab = "V", col = corejunk_true)
#plot(V[,1], main = "Spectral leading eigenvector (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:200, junk=201:250")
plot(Tv, main = "Local method statistic (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:200, junk=201:250", ylab = "V", col = corejunk_true)
plot(Vh[,1], main = "Leading eigenvector of spectral method (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:50, junk=51:250", ylab = "V", col = corejunk_true)
#plot(V[,1], main = "Spectral leading eigenvector (alpha=1, dirichlet=0.1, rho=1)", xlab = "Core=1:200, junk=201:250")
plot(Tv, main = "Local method statistic (alpha=1, dirichlet=0.1, rho=1)",
xlab = "Core=1:50, junk=51:250", ylab = "V", col = corejunk_true)
Sys.getenv("R_LIBS_USER")
library(devtools)
devtools::document()
setwd("~/Box Sync/Git")
setwd("~/Box Sync/Git/graphclass")
library(devtools)
devtools::document()
roxygen2::roxygenise()
devtools::build(manual = TRUE)
install.packages(repos=NULL, "../graphclass_1.0.tar.gz")
library(graphclass)
detach(graphclass())
detach(graphclass
)
detach(graphclass)
detach("graphclass")
?detach
detach("package:graphclass", unload=TRUE)
library(graphclass)
library(graphclass)
?graphclass
install.packages(repos=NULL, "../graphclass_1.0.tar.gz")
?graphclass
?graphclass
library(graphclass)
?graphclass
library(graphclass)
?remove.packages("graphclass")
remove.packages("graphclass")
library(graphclass)
library(graphclass)
library(graphclass)
install.packages(repos=NULL, "../graphclass_1.0.tar.gz")
library(graphclass)
library(devtools)
devtools::document()
roxygen2::roxygenise()
devtools::build(manual = TRUE)
library(graphclass)
remove.packages("graphclass")
install.packages(repos=NULL, "../graphclass_1.0.tar.gz")
library(graphclass)
devtools::document()
roxygen2::roxygenise()
devtools::build(manual = TRUE)
install.packages(repos=NULL, "../graphclass_1.0.tar.gz")
library(graphclass)
plot_adjmatrix()
plot_adjmatrix
