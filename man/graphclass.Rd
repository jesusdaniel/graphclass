% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graphclass.R, R/plot.graphclass.r
\encoding{UTF-8}
\name{graphclass}
\alias{graphclass}
\alias{graphclass.default}
\alias{plot.graphclass}
\title{Regularized logistic regression classifier for networks.}
\usage{
graphclass(
  X = NULL,
  Y = NULL,
  type = c("intersection", "union", "groups", "fusion"),
  ...
)

\method{graphclass}{default}(
  X = NULL,
  Y = NULL,
  Xtest = NULL,
  Ytest = NULL,
  Adj_list = NULL,
  type = c("intersection", "union", "groups", "fusion"),
  lambda = 0,
  rho = 0,
  gamma = 1e-05,
  params = NULL,
  id = "",
  verbose = F,
  D = NULL,
  Groups = NULL,
  G_penalty_factors = NULL,
  ...
)

\method{plot}{graphclass}(object, ...)
}
\arguments{
\item{X}{A matrix with the training samples, in wich each row represents the vectorized (by column order) upper triangular part of a network adjacency matrix.}

\item{Y}{A vector containing the class labels of the training samples (only 2 classes are supported for now).}

\item{type}{Type of penalty function. Default is \code{"intersection".}
See details.}

\item{Xtest}{Optional argument for providing a matrix containing the test samples, with each row representing an upper-triangular vectorized adjacency matrix.}

\item{Ytest}{Optional argument containing the labels of test samples.}

\item{Adj_list}{A training list of of symmetric adjacency matrices with zeros in the diagonal}

\item{lambda}{penalty parameter \eqn{lambda}, by default is set to 0.}

\item{rho}{penalty parameter \eqn{rho} controlling sparsity, by default is set to 0.}

\item{gamma}{ridge parameter (for numerical purposes). Default is \code{gamma = 1e-5}.}

\item{params}{A list containing internal parameters for the optimization algorithm. See details.}

\item{verbose}{whether output is printed}

\item{D}{matrix \eqn{D} used by the penalty to define the groups. This optional argument can be used to pass a precomputed matrix \code{D}, which can be time saving if the method is fitted multiple times. See the function \code{construct_D}.}

\item{Groups}{list of lists, where each list correspond to a grouping and each sublist to sets of indexes in X. Each sublist should be a non-overlapping group.}

\item{G_penalty_factors}{For type "groups", each group is penalized by this factor. Should sum to 1.}

\item{object}{trained graphclass object}
}
\value{
An object containing the trained graph classifier.
\item{beta}{Edge coefficients vector of the regularized logistic regression solution.}
\item{b}{Intercept value.}
\item{Yfit}{Fitted logistic regression probabilities in the train data.}
\item{Ypred}{Predicted class for the test samples (if available).}
\item{train_error}{Percentage of train samples that are misclassified.}
\item{test_error}{Percentage of test samples that are misclassified (if available).}
}
\description{
\code{graphclass} fits a regularized logistic regression to a set of network adjacency matrices with responses, and returns an 
object with the classifier.

Plots the coefficients matrix obtained with 
the function \code{\link{graphclass}}.
}
\details{
The function  \code{graphclass} fits a regularized logistic regression to classify a set of network adjacency matrices
with \eqn{N} labeled nodes and corresponding responses. The classifier fits a matrix of coefficients \eqn{B\in{R}^{N\times N}},
in which \eqn{B_{ij}} indicates the coefficient corresponding to the edge \eqn{(i,j)}.

 The argument \code{type} provides options to choose the penalty function.
If \code{type = "intersection"} or \code{"union"}, the penalty corresponds to the node selection penalty defined as
\deqn{\Omega(B) = \lambda \left(\sum_{i=1}^N\sqrt{\sum_{j=1}^N B_{ij}^2} + \rho \sum_{i=1}^N\sum_{j=1}^N|B_{ij}|\right).}
When \code{type = "intersection"}, a symmetric restriction on  \eqn{B} is enforced, and the penalty promotes subgraph selection.
If \code{type = "union"}, the penalty promotes individual node selection.
See \insertCite{relion2017network;textual}{graphclass} for more details.

The value \code{type = "groups"} corresponds to a generic  group lasso penalty. The groups of edges have to be specified using the argument \code{Groups} with a list of arrays,
in which each element of the list corresponds to a group, and the array indicates the indexes of the variables in that group.
The optional argument \code{G_penalty_factors} is an array of  size equal to the number of groups, and can be used to 
specify different weights for each group on the penalty (for example, when groups have different sizes).

The optional argument \code{params} is a list that allows to control some internal parameters of the optimization algorithm. 
The elements \code{beta_start} and \code{b_start} are  initial values for the optimization algorithm. The value
of \code{beta_start} is a vector that indicates the weights of the upper triangular part of \eqn{B}, and \code{b_start}
is the initial value of the threshold in the logistic regression. By default, these parameters are set to zero. The elements
\code{MAX_ITER} and \code{CONV_CRIT} can be used to change the maximum number of iterations and the convergence criterion in the proximal algorithm
for fitting the node selection penalty (see \insertCite{relion2017network;textual}{graphclass}). By default, these values are set to
\code{MAX_ITER=300} and \code{CONV_CRIT = 1e-5}.
}
\examples{

# Load COBRE data
data(COBRE.data)
X <- COBRE.data$X.cobre
Y <- COBRE.data$Y.cobre

# An example of the subgraph selection penalty
gc = graphclass(X = X, Y = factor(Y), type = "intersection",
               lambda = 1e-4, rho = 1, gamma = 1e-5)
plot(gc)


# 5-fold cross validation
fold_index <- (1:length(Y) \%\% 5) + 1

# Make penalty matrix in advance to save time
D263 <- construct_D(nodes = 263)

gclist <- list()
for(fold in 1:5) {
    foldout <- which(fold_index == fold) 
    gclist[[fold]] <- graphclass(X = X[-foldout,], Y = factor(Y[-foldout]),
                     Xtest = X[foldout,], Ytest = factor(Y[foldout]),
                     type = "intersection",
                     lambda = 1e-4, rho = 1, gamma = 1e-5,
                     D = D263)
}
# test error on each fold
lapply(gclist, function(gc) gc$test_error)

data(COBRE.data)
X <- COBRE.data$X.cobre
Y <- COBRE.data$Y.cobre

# An example of the subgraph selection penalty
gc = graphclass(X, Y = factor(Y), lambda = 1e-5, rho = 1)

plot(gc)
}
\references{
\insertRef{relion2017network}{graphclass}
}
\seealso{
\code{\link{plot.graphclass}}, \code{\link{predict.graphclass}}
}
